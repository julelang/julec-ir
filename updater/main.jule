// Copyright 2023-2025 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/io"
use "std/jule/dist"
use "std/os"
use "std/strings"

struct Dist {
	os:   str
	arch: str
}

let mut LatestHash: str = ""

let Dists: [...]Dist = [
	// Windows
	{os: dist::Windows, arch: dist::AMD64},
	{os: dist::Windows, arch: dist::I386},
	{os: dist::Windows, arch: dist::ARM64},

	// Linux
	{os: dist::Linux, arch: dist::AMD64},
	{os: dist::Linux, arch: dist::I386},
	{os: dist::Linux, arch: dist::ARM64},

	// Darwin
	{os: dist::Darwin, arch: dist::AMD64},
	{os: dist::Darwin, arch: dist::ARM64},
]

fn readLineFromFile(mut f: &os::File): str {
	mut line := make([]byte, 0, 100)
	let mut b: []byte = [0]
	for b[0] != '\n' {
		n := f.Read(b) else {
			println("file cannot read")
			os::Exit(1)
			use 0 // Avoid error.
		}
		if n == io::EOF || n == 0 {
			break
		}
		line = append(line, b...)
	}
	ret strings::TrimRight(str(line), "\b\r\t\n\v ")
}

fn updateIncludePaths(targetPath: str) {
	mut f := os::OpenFile(targetPath, os::O_RDWR, 0o660) else {
		println("file cannot open: " + targetPath)
		os::Exit(1)
		ret // Avoid error.
	}

	mut includeSaw := 0
	for {
		mut line := readLineFromFile(f)
		if len(line) == 0 {
			continue
		}

		if strings::HasPrefix(line, `#include <`) {
			continue
		}
		if !strings::HasPrefix(line, `#include "`) {
			if includeSaw == 2 {
				break
			}
			continue
		} else if includeSaw < 2 {
			includeSaw++
		}

		f.Seek(i64(-len(line))-1, io::SeekCurrent)!

		lineLen := len(line)

		const SearchSubs = "/jule/"
		pos := strings::Index(line, SearchSubs)

		// Remove root directories.
		line = line[pos+len(SearchSubs):]
		line = `#include "` + line
		line += strings::Repeat(" ", lineLen-len(line))
		line += "\n"

		f.Write(([]byte)(line))!
	}
	f.Close()!
}

fn generateIrs() {
	const PATH_JULEC = "./bin/julec"
	const PATH_PACKAGE = "./src/julec"

	for _, dist in Dists {
		target := str(dist.os) + "-" + str(dist.arch)
		targetPath := `./dist/` + target + `.cpp`

		runCommand(PATH_JULEC, "build", "-pt", "--opt", "L2", "--target", target, PATH_PACKAGE)
		runCommand("mv", "./dist/ir.cpp", targetPath)
		updateIncludePaths(targetPath)
	}
}

fn setupJulecIr() {
	const URL = "https://github.com/julelang/julec-ir"
	runCommand("git", "clone", "--depth", "1", URL) // Clone JuleC-IR repository.
	runCommand("rm", "-rf", "julec-ir/src")         // Remove sources.
	runCommand("mkdir", "julec-ir/src")             // Create new source directory.
}

fn moveIrsIntoJulecIr() {
	for _, dist in Dists {
		target := str(dist.os) + "-" + str(dist.arch)
		targetPath := target + `.cpp`
		runCommand("mv", "./dist/"+targetPath, "./julec-ir/src/"+targetPath)
	}
}

fn cleanup() {
	runCommand("rm", "-rf", "./dist")     // Remove dist directory.
	runCommand("rm", "-rf", "./julec-ir") // Remove JuleC-IR clone.
}

fn getLastCommitHash(): str {
	output := runCommandWithOutput("git", "rev-parse", "HEAD")
	ret strings::TrimRight(str(output), "\n\t\r\b\v ")
}

fn setLatestHash() {
	LatestHash = getLastCommitHash()
}

fn updateReadmeCommit() {
	const UrlTree = `https://github.com/julelang/jule/tree/`
	const ReadmePath = `./julec-ir/README.md`

	mut f := os::OpenFile(ReadmePath, os::O_RDWR, 0o660) else {
		println("file cannot open: " + ReadmePath)
		os::Exit(1)
		ret // Avoid error.
	}

	for {
		mut line := readLineFromFile(f)
		if !strings::HasPrefix(line, `IR version: [`) {
			continue
		}

		f.Seek(i64(-len(line))-1, io::SeekCurrent)!

		lineLen := len(line)

		commitHash := LatestHash
		line = "IR version: [`" + commitHash[:10] + "`](" + UrlTree + commitHash + ")"
		line += strings::Repeat(" ", lineLen-len(line))
		line += "\n"

		f.Write(([]byte)(line))!
		break
	}
	f.Close()!
}

fn pushChanges() {
	os::Chdir("julec-ir") else {
		println("working path cannot changed")
		os::Exit(1)
	}

	runCommandTry("git", "add", ".")
	runCommandTry("git", "commit", "-am", "update IRs to commit: "+LatestHash)
	runCommandTry("git", "push")

	os::Chdir("..") else {
		println("working path cannot changed")
		os::Exit(1)
	}
}

// Runs command and exits program if returns non-zero.
fn runCommand(cmd: str, mut args: ...str) {
	ok := runCommandTry(cmd, args...)
	if !ok {
		os::Exit(1)
	}
}

fn runCommandTry(cmd: str, mut args: ...str): bool {
	ocmd := os::Cmd.New(cmd, args...)
	ocmd.Stdout(os::Stdout())!
	ocmd.Stderr(os::Stderr())!
	ocmd.Start()!
	r := ocmd.Wait()!
	ret r == 0
}

// Same as runCommand but reads output from stdout.
fn runCommandWithOutput(cmd: str, mut args: ...str): []byte {
	ocmd := os::Cmd.New(cmd, args...)
	mut pipe := ocmd.StdoutPipe()!
	ocmd.Start()!
	mut bytes := io::ReadAll(pipe)!
	r := ocmd.Wait()!
	const ExitCode = 1
	if r != 0 {
		os::Exit(ExitCode)
	}
	ret bytes
}

fn main() {
	setLatestHash()
	generateIrs()
	setupJulecIr()
	moveIrsIntoJulecIr()
	updateReadmeCommit()
	pushChanges()
	cleanup()
}
